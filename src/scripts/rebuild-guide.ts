/**
 * bun run rebuild
 *
 * Reads all .md files in data/chunks/, extracts front matter from each,
 * and rebuilds guide.yaml from scratch.
 *
 * Use after:
 *   - Manual chunk deletions
 *   - Bulk status changes
 *   - Any time guide.yaml is suspected to be out of sync
 */

import { readFile, writeFile, readdir } from "fs/promises";
import { join } from "path";
import type { GuideEntry } from "../schemas.js"; // GAP-D1-07: single source of truth
import { CONFIG } from "../config.js";

const CHUNKS_DIR = CONFIG.paths.chunks;
const GUIDE_PATH = CONFIG.paths.guide;

// â”€â”€â”€ Front matter extractor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// GuideEntry type is now imported from schemas.ts (GAP-D1-07 â€” no local duplicate)

function extractFrontMatter(raw: string, fileName: string): GuideEntry | null {
  const fmMatch = raw.match(/^---\n([\s\S]*?)\n---/);
  if (!fmMatch) {
    console.warn(`  âš ï¸  No front matter found in ${fileName} â€” skipping`);
    return null;
  }

  const fm = fmMatch[1]!;

  const chunk_id = fm.match(/^chunk_id:\s*(.+)$/m)?.[1]?.trim() ?? "";
  const topic = fm.match(/^topic:\s*(.+)$/m)?.[1]?.trim() ?? "";
  const summary = fm.match(/^summary:\s*>\s*\n\s+(.+)$/m)?.[1]?.trim() ?? "";
  const has_conditions =
    fm.match(/^has_conditions:\s*(true|false)$/m)?.[1] === "true";
  const escalationRaw =
    fm.match(/^escalation:\s*(.+)$/m)?.[1]?.trim() ?? "null";
  const escalation =
    escalationRaw === "null" ? null : escalationRaw.replace(/^"|"$/g, "");
  const status = (fm.match(/^status:\s*(\w+)$/m)?.[1]?.trim() ??
    "active") as GuideEntry["status"];

  const triggersSection = fm.match(/^triggers:\s*\n((?:\s+- .+\n?)*)/m);
  const triggers = triggersSection?.[1]
    ? [...triggersSection[1].matchAll(/- "?(.+?)"?\s*$/gm)].map((m) =>
        m[1]!.trim(),
      )
    : [];

  const relatedSection = fm.match(/^related_chunks:\s*\n((?:\s+- .+\n?)*)/m);
  const related_chunks = relatedSection?.[1]
    ? [...relatedSection[1].matchAll(/- (.+?)\s*$/gm)].map((m) =>
        // Normalize: strip accidental 'chunk_id:' prefixes (GAP-D1-05)
        m[1]!.trim().replace(/^chunk_id:/i, ""),
      )
    : [];

  if (!chunk_id || !topic) {
    console.warn(`âš ï¸ Missing chunk_id or topic in ${fileName} â€” skipping`);
    return null;
  }

  return {
    chunk_id,
    topic,
    summary,
    triggers,
    has_conditions,
    escalation,
    related_chunks,
    status,
    file: `data/chunks/${fileName}`,
  };
}

// â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function main() {
  console.log("\nğŸ”¨ Rebuilding guide.yaml from chunk front matter...\n");

  let files: string[];
  try {
    files = (await readdir(CHUNKS_DIR)).filter((f) => f.endsWith(".md"));
  } catch {
    console.error(`âŒ Could not read chunks directory: ${CHUNKS_DIR}`);
    console.error("   Run bun run extract first.");
    process.exit(1);
  }

  if (files.length === 0) {
    console.warn("âš ï¸  No .md files found in data/chunks/");
    process.exit(0);
  }

  console.log(`ğŸ“‚ Found ${files.length} chunk file(s)\n`);

  const entries: GuideEntry[] = [];
  let skippedTotal = 0;

  for (const file of files.sort()) {
    const raw = await readFile(join(CHUNKS_DIR, file), "utf-8");
    const entry = extractFrontMatter(raw, file);
    if (entry) {
      if (entry.status !== "active") {
        console.log(
          `  â­ï¸  Skipping ${file} [${entry.status}] â€” excluded from index`,
        );
        skippedTotal++;
        continue;
      }
      entries.push(entry);
      console.log(`  âœ… ${file} â†’ ${entry.chunk_id} [${entry.status}]`);
    }
  }

  const lines: string[] = [
    "# Knowledge Base Guide Index",
    "# Auto-generated by rebuild-guide.ts â€” do not edit manually",
    "# Source of truth: individual chunk .md files in data/chunks/",
    "",
    "chunks:",
    "",
  ];

  for (const entry of entries) {
    lines.push(`  - chunk_id: ${entry.chunk_id}`);
    lines.push(`    topic: ${entry.topic}`);
    lines.push(`    summary: >`);
    lines.push(`      ${entry.summary}`);
    lines.push(`    triggers:`);
    for (const t of entry.triggers) {
      lines.push(`      - "${t.replace(/"/g, "'")}"`);
    }
    lines.push(`    has_conditions: ${entry.has_conditions}`);
    if (entry.escalation) {
      lines.push(`    escalation: "${entry.escalation.replace(/"/g, "'")}"`);
    } else {
      lines.push(`    escalation: null`);
    }
    lines.push(`    related_chunks:`);
    for (const r of entry.related_chunks) {
      lines.push(`      - ${r}`);
    }
    lines.push(`    status: ${entry.status}`);
    lines.push(`    file: ${entry.file}`);
    lines.push("");
  }

  const guideContent = lines.join("\n");
  await writeFile(GUIDE_PATH, guideContent, "utf-8");

  const active = entries.filter((e) => e.status === "active").length;
  const review = entries.filter((e) => e.status === "review").length;
  const deprecated = entries.filter((e) => e.status === "deprecated").length;

  console.log(`\nğŸ“˜ guide.yaml rebuilt`);
  console.log(`   Total:      ${entries.length}`);
  console.log(`   Active:     ${active}`);
  console.log(`   Review:     ${review}`);
  console.log(`   Deprecated: ${deprecated}`);

  // â”€â”€ Guide Size Enforcement (Task D1-04) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const guideSize = guideContent.length;
  const MAX_GUIDE_SIZE = 30000; // Recommended limit for high-accuracy retrieval

  if (guideSize > MAX_GUIDE_SIZE) {
    console.warn(
      `\nâš ï¸  CRITICAL: guide.yaml is ${guideSize} chars. This exceeds the ${MAX_GUIDE_SIZE} recommended limit.`,
    );
    console.warn(
      `   Retrieval accuracy may drop as the LLM context window fills up.`,
    );
    console.warn(`   Action: Deprecate old chunks or combine topics.`);
  } else {
    console.log(`   Size:       ${guideSize} chars (Healthy)\n`);
  }
}

main().catch((err) => {
  console.error("âŒ Rebuild failed:", err);
  process.exit(1);
});
