/**
 * bun run rebuild
 *
 * Reads all .md files in data/chunks/, extracts front matter from each,
 * and rebuilds guide.yaml from scratch.
 *
 * Use after:
 *   - Manual chunk deletions
 *   - Bulk status changes
 *   - Any time guide.yaml is suspected to be out of sync
 */

import { readFile, writeFile, readdir } from "fs/promises";
import { join } from "path";
import type { GuideEntry } from "../schemas.js"; // GAP-D1-07: single source of truth
import { CONFIG } from "../config.js";
import { logger } from "../logger.js";

const CHUNKS_DIR = CONFIG.paths.chunks;
const GUIDE_PATH = CONFIG.paths.guide;

// ─── Front matter extractor ────────────────────────────────────────────────────

// GuideEntry type is now imported from schemas.ts (GAP-D1-07 — no local duplicate)

function extractFrontMatter(raw: string, fileName: string): GuideEntry | null {
  const fmMatch = raw.match(/^---\n([\s\S]*?)\n---/);
  if (!fmMatch) {
    logger.warn("No front matter found in file", { fileName });
    return null;
  }

  const fm = fmMatch[1]!;

  const chunk_id = fm.match(/^chunk_id:\s*(.+)$/m)?.[1]?.trim() ?? "";
  const source = fm.match(/^source:\s*(.+)$/m)?.[1]?.trim() ?? "unknown";
  const topic = fm.match(/^topic:\s*(.+)$/m)?.[1]?.trim() ?? "";
  const summary = fm.match(/^summary:\s*>\s*\n\s+(.+)$/m)?.[1]?.trim() ?? "";
  const has_conditions =
    fm.match(/^has_conditions:\s*(true|false)$/m)?.[1] === "true";
  const status = (fm.match(/^status:\s*(\w+)$/m)?.[1]?.trim() ??
    "active") as GuideEntry["status"];

  const triggersSection = fm.match(/^triggers:\s*\n((?:\s+- .+\n?)*)/m);
  const triggers = triggersSection?.[1]
    ? [...triggersSection[1].matchAll(/- "?(.+?)"?\s*$/gm)].map((m) =>
        m[1]!.trim(),
      )
    : [];

  const relatedSection = fm.match(/^related_chunks:\s*\n((?:\s+- .+\n?)*)/m);
  const related_chunks = relatedSection?.[1]
    ? [...relatedSection[1].matchAll(/- (.+?)\s*$/gm)].map((m) =>
        // Normalize: strip accidental 'chunk_id:' prefixes (GAP-D1-05)
        m[1]!.trim().replace(/^chunk_id:/i, ""),
      )
    : [];

  if (!chunk_id || !topic) {
    logger.warn("Missing chunk_id or topic in file", { fileName });
    return null;
  }

  return {
    chunk_id,
    source,
    topic,
    summary,
    triggers,
    has_conditions,
    related_chunks,
    status,
  };
}

// ─── Main ──────────────────────────────────────────────────────────────────────

async function main() {
  logger.info("Rebuilding guide.yaml from chunk front matter");

  let files: string[];
  try {
    files = (await readdir(CHUNKS_DIR)).filter((f) => f.endsWith(".md"));
  } catch {
    logger.error("Could not read chunks directory", { dir: CHUNKS_DIR });
    process.exit(1);
  }

  if (files.length === 0) {
    logger.warn("No .md files found in chunks directory", { dir: CHUNKS_DIR });
    process.exit(0);
  }

  logger.info("Chunk files found", { count: files.length });

  const entries: GuideEntry[] = [];
  let skippedTotal = 0;

  for (const file of files.sort()) {
    const raw = await readFile(join(CHUNKS_DIR, file), "utf-8");
    const entry = extractFrontMatter(raw, file);
    if (entry) {
      if (entry.status !== "active") {
        logger.debug("Skipping non-active chunk", {
          file,
          status: entry.status,
        });
        skippedTotal++;
        continue;
      }
      entries.push(entry);
      logger.debug("Chunk indexed", {
        file,
        chunkId: entry.chunk_id,
        status: entry.status,
      });
    }
  }

  const lines: string[] = [
    "# Knowledge Base Guide Index",
    "# Auto-generated by rebuild-guide.ts — do not edit manually",
    "# Source of truth: individual chunk .md files in data/chunks/",
    "",
    "chunks:",
    "",
  ];

  for (const entry of entries) {
    lines.push(`  - chunk_id: ${entry.chunk_id}`);
    lines.push(`    source: ${entry.source}`);
    lines.push(`    topic: ${entry.topic}`);
    lines.push(`    summary: >`);
    lines.push(`      ${entry.summary}`);
    lines.push(`    triggers:`);
    for (const t of entry.triggers) {
      lines.push(`      - "${t.replace(/"/g, "'")}"`);
    }
    lines.push(`    has_conditions: ${entry.has_conditions}`);
    lines.push(`    related_chunks:`);
    for (const r of entry.related_chunks) {
      lines.push(`      - ${r}`);
    }
    lines.push(`    status: ${entry.status}`);
    lines.push("");
  }

  const guideContent = lines.join("\n");
  await writeFile(GUIDE_PATH, guideContent, "utf-8");

  const active = entries.filter((e) => e.status === "active").length;
  const review = entries.filter((e) => e.status === "review").length;
  const deprecated = entries.filter((e) => e.status === "deprecated").length;

  // ── Guide Size Enforcement (Task D1-04) ──────────────────────────────────
  const guideSize = guideContent.length;
  const MAX_GUIDE_SIZE = 30000; // Recommended limit for high-accuracy retrieval

  if (guideSize > MAX_GUIDE_SIZE) {
    logger.warn(
      "guide.yaml exceeds recommended size limit — retrieval accuracy may drop",
      {
        currentChars: guideSize,
        maxChars: MAX_GUIDE_SIZE,
        recommendation: "Deprecate old chunks or combine topics",
      },
    );
  } else {
    logger.info("guide.yaml rebuilt successfully", {
      totalEntries: entries.length,
      active,
      review,
      deprecated,
      skipped: skippedTotal,
      sizeChars: guideSize,
    });
  }
}

main().catch((err) => {
  logger.error("Rebuild failed", {
    error: err instanceof Error ? err.message : String(err),
  });
  process.exit(1);
});
